
我在使用ai编程修复bug时，当我直接把问题丢给ai，ai会进行大量的检索工作，非常浪费token，我想要做个子智能体，核心目标是实现**“高效率、低成本、高精度的上下文预处理”**。该子智能体的目标是作为主智能体的**“眼睛”和“地图导购”**，负责**跑腿搜集证据**并**指明关键方位**，从而让主智能体这个**“大脑”**能在最短的时间内、用最少的开销，基于最准确的代码事实做出修复决策。
具体可以概括为以下四个核心维度：
### 1. 成本优化（Cost Efficiency）
*   **算力分级**：将“翻阅大量代码、搜索关键词、整理文件结构”等资源消耗大、但逻辑难度低的**体力劳动**，交给价格极低的低阶模型。
*   **Token 瘦身**：通过只产出“文件路径+行号索引”而非大段代码，极大地节省了主智能体（高阶模型）的输入 Token 消耗，把昂贵的算力用在真正的逻辑推理上。

### 2. 认知聚焦（Cognitive Focus）
*   **脱水与精炼**：将用户模糊的自然语言描述，转化为程序员视角下的“逻辑地图”。
*   **排除噪音**：主智能体不再需要处理几千行无关代码，而是通过子智能体指路，直接“精准打击”关键逻辑块，避免主智能体因上下文过载而产生逻辑混乱（Lost in the Middle）。

### 3. 证据导向（Evidence-Based Debugging）
*   **索引化引用**：主智能体通过子智能体提供的“地址”亲自读取源码，而不是被动接受子智能体转述的代码，保证了信息的**原始性**和**完整性**。
*   **事实与判断分离**：明确区分“代码事实（文件/行号/逻辑流）”与“初步推测（假设）”，防止子智能体较低的智力水平产生的误判污染了主智能体的决策，确保主智能体保持独立思考。

### 4. 自动化工程闭环（Workflow Automation）
*   **建立“专家-助手”协作模式**：主智能体扮演“首席架构师”，负责下令；子智能体扮演“侦察员”，负责踩点。
*   **标准化产出**：通过固定的报告模板，为主智能体提供结构化的、一致的输入，使得 Debug 过程从“碰运气搜索”变成“标准化作业”。

```

```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5OTgyMDI4NzEsLTgyNDg5NjczMSwxOT
c4Mzg2MTQ5LDE5Nzg4MDYzNTAsLTE1OTc1Nzc5OTIsLTE3OTk1
MTA1MDEsLTE4MTE3MzM0MjZdfQ==
-->